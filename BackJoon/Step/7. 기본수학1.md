### 1712

![image](https://user-images.githubusercontent.com/78454649/157172551-f30b6fa5-c246-4492-b57a-3108119fc026.png)


```java

import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int a = sc.nextInt();
        int b = sc.nextInt();
        int c = sc.nextInt();

        if(c <= b){
            System.out.println("-1");
        }else {
            System.out.println(a/(c-b)+1);
        }


    }
}

```

<br/>

---

### 2292

![image](https://user-images.githubusercontent.com/78454649/157357196-438c7b34-0d98-46e1-8389-cc48cdeb0a08.png)

<br/>

![image](https://user-images.githubusercontent.com/78454649/157357251-6dd8546e-04dd-4c23-ab4a-ae3515edbe6d.png)

방 개수는 6개씩 늘어나는 것을 볼 수 있다.

```java

import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        int N = in.nextInt();
        int count = 1; // 겹 수(최소 루트)
        int range = 2;	// 범위 (최솟값 기준)

        if (N == 1) {
            System.out.print(1);
        }

        else {
            while (range <= N) {	// 범위가 N보다 커지기 직전까지 반복
                range = range + (6 * count);	// 다음 범위의 최솟값으로 초기화
                count++;	// count 1 증가
                
                /* 8 = 2 + (6) 이 처음 실행된다. count 값이 1 증가해서 2가 된다.
				while 문 조건값을 비교한다 range <= n 일 경우 while 문이 한번 더 실행된다.
				14 = 2 + (12)가 두 번째로 실행된다. count 값이 1 증가해서 3이 된다.
				또 while 문 조건값을 비교한다. range <= n일 경우 while 문이 한번 더 실행된다.
				계속해서 반복된다. range > n일 때까지 반복된다.
				 */
                
            }
            System.out.print(count);
        }
        
    }
}

```


<br/>

---

### 1193


```java

import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        int N = in.nextInt();

        int cross_count = 1;
        int prev_count_sum = 0;

        while (true){
            
            // 직전 대각선 누적합 + 해당 대각선 개수 이용한 범위 판별
            if(N <= cross_count + prev_count_sum){

                if(cross_count % 2 == 1){
                
                    // 분모가 큰 수부터 시작
					// 분모는 대각선 개수 - (X 번째 - 직전 대각선까지의 누적합 - 1) 
					// 분자는 X 번째 - 직전 대각선까지의 누적합 
                    System.out.println((cross_count - (N - prev_count_sum -1)) + "/" + (N - prev_count_sum));
                    break;
                }else {
                    System.out.println((N - prev_count_sum) + "/" + (cross_count - (N - prev_count_sum -1)));
                    break;
                }
                
            }else {
                prev_count_sum += cross_count;
                cross_count++;
            }
        }
    }
}

```

* 해설

분모 값과 분자 값의 합을 T 라고 할 때 다음과 같은 규칙이 생긴다.

![image](https://user-images.githubusercontent.com/78454649/157426687-1f6ef8aa-5173-4001-99c8-b00b2432cfe0.png)

그리고 대각선 칸의 개수는 T - 1 개다.

그러면, X 번째의 분수는 어떻게 찾아야 하는가가 문제다.

파란색 ( T 가 짝수, 또는 대각선 칸의 개수가 홀수 ) 일 때는 왼쪽 아래에서 오른쪽 위 방향 ( ↗︎ ) 으로 진행되고, <br/>
빨간색 ( T 가 홀수, 또는 대각선 칸의 개수가 짝수 ) 일 때는 오른쪽 위에서 왼쪽 아래 방향 ( ↙︎ ) 으로 진행된다.

<br/>

즉, T % 2 가 0 일 때는 대각선 위 방향, 1 일 때는 아래 방향으로 진행된다는 것.

1. 입력받을 X 값 <br/> 
2. 해당 범위의 대각선 칸 개수 ( cross_count ) <br/> 
3. 해당 대각선 직전 대각선 까지의 칸의 누적 합 ( prev_count_sum ) <br/>
 
<br/>

이렇게 3 개를 이용하여 X 값이 해당 범위의 값이 나올 때 까지 반복하고,

만약 해당 범위의 값이라면 <br/>
대각선의 개수가 홀수인지, 짝수인지 판별하여 해당 대각선의 첫 원소와 X, 대각선의 개수를 이용하여 분모 분자 값을 구해준다.


<br/>

---












