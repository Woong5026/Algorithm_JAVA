### 2750

<br/>

![image](https://user-images.githubusercontent.com/78454649/215324494-ccad26b7-0d68-42e4-ae70-c2f0801aefb2.png)

<br/>

* 선택정렬

첫 번째 인덱스부터 시작하여 뒤의 인덱스들의 값들과 비교하여 최솟값들을 차곡차곡 쌓아나가는 방법이다. <br/>
가장 구현하기 쉽다는 장점이 있으나 시간복잡도가 O(n2) 으로 그리 좋은 성능의 알고리즘은 아니다. 

```java

import java.util.Scanner;

public class Main {

    public static void main(String[] args) throws Exception{

        Scanner sc = new Scanner(System.in);

        int N = sc.nextInt();
        int arr[] = new int[N];

        for (int i = 0; i < N; i++){
            arr[i] = sc.nextInt();
        }

        for (int i = 0; i < N -1; i++){
            for (int j = i + 1; j < N; j++){
                if(arr[i] > arr[j]){
                    int temp = arr[j];
                    arr[j] = arr[i]; // i번째와 j번째 위치를 바꾸는 코드
                    arr[i] = temp; // 바뀐 i번째(첫번째)에 arr[j]를 넣어주는 코드
                    
                    // i와 j를 비교하고 만약 값이 j의 값이 작았다면 위치가 바뀌었을 것이고
                    // arr[j]를 N번만큼 돌려서 계속 값을 비교하고 가장 작은 값이 맨 앞으로 갈 것이다
                    // j가 N번만큼 다 돌았다면 for문을 빠져나와 i의 두번째를 돌 것이며 이때는 (5,4,3,2)를 비교하고 2가 제일 앞으로 간다
                    // 다음으로는 (5,4,3) (5,4) 순으로 i의 남은 N만큼 for문을 돌아 값을 비교한다
                }
            }
        }

        for(int val : arr) {
            System.out.println(val);
        }

    }

}

```

<br/>

*  Arrays.sort()

 Arrays.sort() 는 자바에서 기본으로 제공되는 메소드로, <br/>
 자체 정렬 알고리즘을 구현 할 필요 없이 sort() 안에 배열만 넣어주면 자동으로 해당 배열이 정렬되어 나온다. <br/>
 Arrays.sort() 의 경우 dual-pivot Quicksort 알고리즘을 쓰고 있기 때문에 시간복잡도는 평균 O(nlogn) 으로 좋은 성능을 내고 있다. 
 
 ```java
 
import java.util.Arrays;
import java.util.Scanner;

public class Main {

    public static void main(String[] args) throws Exception{

        Scanner sc = new Scanner(System.in);

        int N = sc.nextInt();
        int arr[] = new int[N];

        for (int i = 0; i < N; i++){
            arr[i] = sc.nextInt();
        }

        Arrays.sort(arr);

        for(int val : arr) {
            System.out.println(val);
        }

    }

}
 
 
 ```

<br/>

--- 

### 2587

<br/>

![image](https://user-images.githubusercontent.com/78454649/215325593-0fc148a3-da95-46ed-9b12-85aa96f49264.png)

<br/>


```java

import java.util.Arrays;
import java.util.Scanner;

public class Main {

    public static void main(String[] args) throws Exception{

        Scanner sc = new Scanner(System.in);

        int A = sc.nextInt();
        int B = sc.nextInt();
        int C = sc.nextInt();
        int D = sc.nextInt();
        int E = sc.nextInt();

        int arr[] = new int[5];

        arr[0] = A;
        arr[1] = B;
        arr[2] = C;
        arr[3] = D;
        arr[4] = E;

        Arrays.sort(arr);

        System.out.println((A+B+C+D+E)/5);
        System.out.println(arr[2]);

    }

}

```

<br/>

--- 

### 25305

<br/>

![image](https://user-images.githubusercontent.com/78454649/215326146-f527e9a4-b7db-492e-9de8-6f97a8ff372c.png)


<br/>


```java

import java.util.Arrays;
import java.util.Scanner;

public class Main {

    public static void main(String[] args) throws Exception{

        Scanner sc = new Scanner(System.in);

        int N = sc.nextInt();
        int C = sc.nextInt();

        int arr[] = new int[N];

        for (int i = 0; i < N; i++){
            arr[i] = sc.nextInt();
        }

        Arrays.sort(arr);

        System.out.println(arr[N-C]);

    }

}

```

<br/>

--- 

### 2751

<br/>

![image](https://user-images.githubusercontent.com/78454649/215327516-cc4aefa2-3679-4f4f-a8d4-e823f16737cc.png)

<br/>

* Collections.sort()

이 문제는 단순하게 Arrays.sort() 를 쓰지 못하게 일부러 O(n2) 이 걸리도록 저격한 데이터가 있다.
그렇다면 어떻게 해결해야될까? 

Collections.sort() 은 Timsort이다. Timsort 의 경우 합병 및 삽입정렬 알고리즘을 사용한다. <br/>
이렇게 두 가지가 섞여있는 정렬 알고리즘을 hybrid sorting algorithm 이라고 하는데, <br/>
합병정렬(Merge Sort)의 경우 최선, 최악 모두 O(nlogn)을 보장하고 삽입정렬(Insertion sort)의 경우 최선의 경우는 O(n) , 최악의 경우는 O(n2) 이다. <br/>
그리고 두 정렬 모두 안정 정렬(stable sort)이기 때문에 Timsort를 hybrid stable sorting algorithm이라고도 한다.

시간복잡도 O(n) ~ O(nlogn) 을 보장한다는 장점이 있다. 대신에 Collections.sort()를 사용하고자 한다면 
가장 쉬운 방법으로는 일반적인 primitive 배열이 아닌 **List 계열**(ArrayList, LinkedList 등..)의 자료구조를 사용하여 정렬해야한다.

```java

import java.util.Scanner;
import java.util.ArrayList;
import java.util.Collections;


public class Main {
    public static void main(String[] args) {

        Scanner in = new Scanner(System.in);
        StringBuilder sb = new StringBuilder();

        int N = in.nextInt();

        // list 계열 중 하나를 쓰면 된다.
        ArrayList<Integer> list = new ArrayList<>();

        for(int i = 0; i < N; i++) {
            list.add(in.nextInt());
        }

        Collections.sort(list);

        for(int value : list) {
            sb.append(value).append('\n');
        }
        System.out.println(sb);
    }
}

```

+) StringBuilder

처음에 StringBuilder를 사용하지 않고 for문에서 바로 list를 반환하게 했더니 시간초과가 났다 <br/>
그래서 찾아보니 출력이 많은 경우에 StringBuilder를 사용해서 한 문자열로 만들어서 출력을 한번만 사용해야 한다

시간 초과가 날때는 Scanner 로 입력받아 sort 를 쓸 경우 출력은 BufferedWriter 을 쓰던가, StringBuilder를 써서 한 번에 출력해주어야 한다

<br/>

--- 

### 1427

<br/>

![image](https://user-images.githubusercontent.com/78454649/215334199-9ab03f58-3788-4fb0-b534-c6beefac6abd.png)

<br/>

```java

import java.util.Arrays;
import java.util.Collections;
import java.util.Scanner;


public class Main {
    public static void main(String[] args) {

        Scanner sc = new Scanner(System.in);

        String[] split = sc.next().split("");

        Integer arr[] = new Integer[split.length];

        for (int i = 0; i < arr.length; i++){
            arr[i] = Integer.parseInt(split[i]);
        }

        Arrays.sort(arr, Collections.reverseOrder());

        for(int i = 0; i < arr.length; i++)
        {
            System.out.print(arr[i]);
        }


    }
}

```

+) String 배열을 int 배열로 변환하기

1.  Integer.parseInt()로 String 배열을 int 배열로 변환

```java

public class Example {

    public static void main(String[] args) {

        String[] arr = new String[] {"10", "15", "30", "55"};

        int[] newArr = new int[arr.length];
        for (int i = 0; i < arr.length; i++) {
            newArr[i] = Integer.parseInt(arr[i]);
        }

        // output
        for (int i = 0; i < newArr.length; i++) {
            System.out.println("newArr[" + i + "] = " + newArr[i]);
        }
    }
}

```

2. Stream으로 String 배열을 int 배열로 변환

```java

import java.util.stream.Stream;

public class Example2 {

    public static void main(String[] args) {

        String[] arr = new String[] {"10", "15", "30", "55"};

        int[] newArr = Stream.of(arr).mapToInt(Integer::parseInt).toArray();

        // output
        for (int i = 0; i < newArr.length; i++) {
            System.out.println("newArr[" + i + "] = " + newArr[i]);
        }
    }
}

```

<br/>

+) 배열 내림차순

int에서는 Collections.reverseOrder()가 사용을 할 수 없다 <br/>
배열 내림차순을 적용하려면 int[]가 아닌 Interger[]로 변수를 선언

<br/>
